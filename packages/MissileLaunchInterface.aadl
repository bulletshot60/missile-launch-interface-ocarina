package missile_launch_interface
public
	with Base_Types;
	
	--////////////////////////////////////////////////
	-- start devices
	--\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	
	annex Resolute {**
		instantiation_is_reachable(source_component : component, destination_components : {component}) <= **"proves that component" source_component " can reach component " destination_components**
			exists (c : reachable({source_component})) .
				exists (d : destination_components) .
					c = d
			
		reachable(c : {component}) : {component} =
			let next : {component} = union(c, next_reachable(c));
			if c = next then 
				c
			else
				reachable(next)
			
		next_reachable(c : {component}) : {component} = 
			{y for (x : c) (y : reachable_components(x))}
			
		reachable_components(c : component) : {component} = 
			{y for (conn : connections(c)) (y : components_on_connection(c, conn))}
			
		components_on_connection(c : component, conn : connection) : {component} = 
			if is_port_connection(conn) then
				if source_component(conn) = c then
					{destination_component(conn)}
				else
					{}
			else
				{}
	**};
	
	device toggle_switch
		features
			toggled_up: out event port;
			toggled_down: out event port;
		flows
			flow1: flow source toggled_up;
			flow2: flow source toggled_down;
	end toggle_switch;
	
	device implementation toggle_switch.impl
		flows
			flow1: flow source toggled_up;
			flow2: flow source toggled_down;
		annex Resolute {**
			prove(instantiation_is_reachable(this, instances(convert_event_to_boolean)))
		**};
	end toggle_switch.impl;
	
	device button
		features
			pressed: out event port;
			released: out event port;
		flows
			flow1: flow source pressed;
			flow2: flow source released;
	end button;
	
	device implementation button.impl
		flows
			flow1: flow source pressed;
			flow2: flow source released;
		annex Resolute {**
			prove(instantiation_is_reachable(this, instances(convert_event_to_boolean)))
		**};		
	end button.impl;
	
	--////////////////////////////////////////////////
	-- end devices
	--\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	
	--////////////////////////////////////////////////
	-- start subprograms
	--\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	
	subprogram determine_if_enable
		features
			enable_event: in event port;
			disable_event: in event port;
			enabled: out parameter Base_Types::Boolean;
	end determine_if_enable;
	
	subprogram determine_if_launch
		features
			left_toggle_enabled: in parameter Base_Types::Boolean;
			left_button_enabled: in parameter Base_Types::Boolean;
			right_button_enabled: in parameter Base_Types::Boolean;
			right_toggle_enabled: in parameter Base_Types::Boolean;
			launch_missile: out event data port Base_Types::Boolean;
	end determine_if_launch;
	
	--////////////////////////////////////////////////
	-- end subprograms
	--\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	
	--////////////////////////////////////////////////
	-- start threads
	--\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	
	thread clock_thread
		features
			time_interrupt: out event port;
		properties
			Dispatch_Protocol => Periodic;
			Period => 1ms;
	end clock_thread;
	
	thread implementation clock_thread.impl
	end clock_thread.impl;
	
	thread convert_event_to_boolean
		features
			enable_event: in event port;
			disable_event: in event port;
			enabled: out data port Base_Types::Boolean;
	end convert_event_to_boolean;
	
	thread implementation convert_event_to_boolean.impl
		calls M: {
			method: subprogram determine_if_enable;
		};
		connections
			event1: port enable_event->method.enable_event;
			event2: port disable_event->method.disable_event;
			output1: parameter method.enabled->enabled;
	end convert_event_to_boolean.impl;
	
	thread launch_interface_thread
		features
			left_toggle_enabled: in data port Base_Types::Boolean;
			left_button_enabled: in data port Base_Types::Boolean;
			right_button_enabled: in data port Base_Types::Boolean;
			right_toggle_enabled: in data port Base_Types::Boolean;
			launch_missile: out event data port Base_Types::Boolean;
		annex agree {**
			guarantee "will launch or not launch missile": launch_missile = true or launch_missile = false;
		**};
	end launch_interface_thread;
	
	thread implementation launch_interface_thread.impl
		calls M: {
			method: subprogram determine_if_launch;
		};
		connections
			input1: parameter left_toggle_enabled->method.left_toggle_enabled;
			input2: parameter left_button_enabled->method.left_button_enabled;
			input3: parameter right_button_enabled->method.right_button_enabled;
			input4: parameter right_toggle_enabled->method.right_toggle_enabled;
			output1: port method.launch_missile->launch_missile;
		annex agree {**
			assert launch_missile = prev(left_toggle_enabled and left_button_enabled and right_button_enabled and right_toggle_enabled, false);
		**};
	end launch_interface_thread.impl;
	
	--////////////////////////////////////////////////
	-- end threads
	--\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	
	--////////////////////////////////////////////////
	-- start processes
	--\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
		
	process clock_process
		features
			time: out data port Base_Types::Integer;
		annex agree {**
			guarantee "clock value will be greater than or equal to 0": time >= 0;
		**};
	end clock_process;
	
	process implementation clock_process.impl
		subcomponents
			time_interrupt_thread: thread clock_thread.impl;
		annex agree {**
			node Counter(init:int, incr: int, reset: bool) returns(count: int);
			let
				count = if reset then init
				else prev(count, init)+incr;
			tel;
			
			eq x1 : int = Counter(0, 1, prev(x1 = 86400000, false));
			
			assert time = x1;
		**};
	end clock_process.impl;
		
	process launch_interface_process
		features
			left_toggle_up: in event port;
			left_toggle_down: in event port;
			left_button_pressed: in event port;
			left_button_released: in event port;
			right_button_pressed: in event port;
			right_button_released: in event port;
			right_toggle_up: in event port;
			right_toggle_down: in event port;
			timer_fire: in event port;
			launch_missile: out event data port Base_Types::Boolean;
		annex agree {**
			guarantee "missle will launch or not launch": launch_missile = true or launch_missile = false; 
		**};
	end launch_interface_process;
	
	process implementation launch_interface_process.impl
		subcomponents
			left_toggle_read_thread: thread convert_event_to_boolean.impl;
			right_toggle_read_thread: thread convert_event_to_boolean.impl;
			left_button_read_thread: thread convert_event_to_boolean.impl;
			right_button_read_thread: thread convert_event_to_boolean.impl;
			launch_interface_thread: thread launch_interface_thread.impl;
		connections
			event1: port left_toggle_up->left_toggle_read_thread.enable_event;
			event2: port left_toggle_down->left_toggle_read_thread.disable_event;
			event3: port right_toggle_up->right_toggle_read_thread.enable_event;
			event4: port right_toggle_down->right_toggle_read_thread.disable_event;
			event5: port left_button_pressed->left_button_read_thread.enable_event;
			event6: port left_button_released->left_button_read_thread.disable_event;
			event7: port right_button_pressed->right_button_read_thread.enable_event;
			event8: port right_button_released->right_button_read_thread.disable_event;
			connection1: port left_toggle_read_thread.enabled->launch_interface_thread.left_toggle_enabled;
			connection2: port right_toggle_read_thread.enabled->launch_interface_thread.right_toggle_enabled;
			connection3: port left_button_read_thread.enabled->launch_interface_thread.left_button_enabled;
			connection4: port right_button_read_thread.enabled->launch_interface_thread.right_button_enabled;
			output1: port launch_interface_thread.launch_missile->launch_missile;
	end launch_interface_process.impl;
	
	--////////////////////////////////////////////////
	-- end processes
	--\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	
	--////////////////////////////////////////////////
	-- start systems
	--\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	
	system launch_interface_system
		features
			launch_missile: out event data port Base_Types::Boolean;
			error: out event data port Base_Types::Boolean;
		annex agree {**
			guarantee "will launch or not launch missile": launch_missile = true or launch_missile = false;
		**};
	end launch_interface_system;
	
	system implementation launch_interface_system.impl
		subcomponents
			clock_process: process clock_process.impl;
			left_toggle: device toggle_switch.impl;
			left_button: device button.impl;
			right_button: device button.impl;
			right_toggle: device toggle_switch.impl;
			launch_interface_process: process launch_interface_process.impl;
		connections
			event1: port left_toggle.toggled_up->launch_interface_process.left_toggle_up;
			event2: port left_toggle.toggled_down->launch_interface_process.left_toggle_down;
			event3: port left_button.pressed->launch_interface_process.left_button_pressed;
			event4: port left_button.released->launch_interface_process.left_button_released;
			event5: port right_button.pressed->launch_interface_process.right_button_pressed;
			event6: port right_button.released->launch_interface_process.right_button_released;
			event7: port right_toggle.toggled_up->launch_interface_process.right_toggle_up;
			event8: port right_toggle.toggled_down->launch_interface_process.right_toggle_down;
			event9: port clock_process.time->launch_interface_process.timer_fire;
			event10: port launch_interface_process.launch_missile->launch_missile;
	end launch_interface_system.impl;
	
	--////////////////////////////////////////////////
	-- end systems
	--\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	
end missile_launch_interface;